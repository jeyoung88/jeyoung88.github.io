---
layout: post
title: Guard, Interceptor
categories: [pdf-service]
tags: [guard,interceptor]
---

## Step 1 Guard
Guard is the first step in the pipeline of the HTTP POST that will be activated . It can be applied at the Controller level such as **@UseGuards(HeaderGuard)** . It is used mainly to authenticate the service. I utilize it to do validations such as validating. The implementation of Guard decorator is very boiler-plated. Below I list portion of the source code on my Header Validation Guard.
```typescript
@Injectable()
export class HeaderGuard implements CanActivate {
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {

    // console.log("guard");
    const req = context.switchToHttp().getRequest();
    const headers = req.headers;

    //validate caller has the right token:       
    //Authentication: Bearer 'token'
    try{
      const bheader = getHeader("Authentication", headers);
      const token=bheader.replace('Bearer ', '');
      const decoded = jwt.verify(token, SECRET);
    }
    catch(err){
      throw new HttpException("Missing header token", HttpStatus.UNAUTHORIZED);
    }

    // const path = getHeader("path", req.headers);
    const my_tz = getHeader("my-tz", headers);
    const curr = getHeader("my-$", headers, "USD");
    const locale = getHeader("accept-language", headers, "en-us");

  
   if (my_tz) {
      if (!moment.tz.zone(my_tz)) {
        throw new HttpException("Invalid header value: my-tz", HttpStatus.BAD_REQUEST);
      }
    } else {
      throw new HttpException("Missing header: my-tz", HttpStatus.BAD_REQUEST);
    }

    ...
    return true;
  }

```
---
## Step 2 Interceptor
After the Guards are activated, follows are Interceptors. It can be applied at the Controller level such as **@UseInterceptors(MyInterceptor)** . This is the place where I attempt to load document specific **Handlebars Helper Functions** from the document directory  **code/ext.js** . The separation of shared system Helper Functions vs document customization is necessary because otherwise it can <em>pollute</em> other document by carrying the unused logics and name spaces to the global level. A fragment of the implementation is as follows:

```typescript
@Injectable()
export class ExtInterceptor implements NestInterceptor {
  constructor(private loaderService: LoaderService) {
  }

  async intercept(context: ExecutionContext, next: CallHandler): Promise<Observable<any>> {
    // console.log("interceptor");

    const req = context.switchToHttp().getRequest();

    const path = req.headers["path"];

    if (!path) {
      throw new HttpException("Missing header: path", HttpStatus.BAD_REQUEST);
    }

    ...
    // loading extension
    try {
      await this.loaderService.load(path, req);
    }
    catch (e) {
      throw new HttpException(`Load extension exception: ${e.message}`, HttpStatus.BAD_REQUEST);
    }

    ...
    return next.handle();
  }
}
```
---